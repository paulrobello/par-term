//! Flow control and miscellaneous tmux notification handlers.
//!
//! Covers pane focus changes, error reporting, pause/continue flow control,
//! and the (currently dead-code) sync-action dispatcher.

use crate::app::window_state::WindowState;
use crate::tmux::SyncAction;

impl WindowState {
    /// Handle pane focus changed notification from external tmux
    pub(super) fn handle_tmux_pane_focus_changed(&mut self, tmux_pane_id: crate::tmux::TmuxPaneId) {
        crate::debug_info!("TMUX", "Pane focus changed to %{}", tmux_pane_id);

        // Update the tmux session's focused pane
        if let Some(session) = &mut self.tmux_state.tmux_session {
            session.set_focused_pane(Some(tmux_pane_id));
        }

        // Update the native pane focus to match
        if let Some(native_pane_id) = self.tmux_state.tmux_pane_to_native_pane.get(&tmux_pane_id) {
            // Find the tab containing this pane and update its focus
            if let Some(tab) = self.tab_manager.active_tab_mut()
                && let Some(pm) = tab.pane_manager_mut()
            {
                pm.focus_pane(*native_pane_id);
                crate::debug_info!(
                    "TMUX",
                    "Updated native pane focus: tmux %{} -> native {}",
                    tmux_pane_id,
                    native_pane_id
                );
            }
        }
    }

    /// Handle error notification
    pub(super) fn handle_tmux_error(&mut self, msg: &str) {
        crate::debug_error!("TMUX", "Error from tmux: {}", msg);

        // Show notification to user
        self.deliver_notification("tmux Error", msg);
    }

    /// Handle pause notification (for slow connections)
    pub(super) fn handle_tmux_pause(&mut self) {
        crate::debug_info!("TMUX", "Received pause notification - buffering output");

        // Set paused state in sync manager
        self.tmux_state.tmux_sync.pause();

        // Show toast notification to user
        self.show_toast("tmux: Output paused (slow connection)");
    }

    /// Handle continue notification (resume after pause)
    pub(super) fn handle_tmux_continue(&mut self) {
        crate::debug_info!("TMUX", "Received continue notification - resuming output");

        // Get and flush buffered output
        let buffered = self.tmux_state.tmux_sync.resume();

        // Flush buffered data to each pane
        for (tmux_pane_id, data) in buffered {
            if !data.is_empty() {
                crate::debug_info!(
                    "TMUX",
                    "Flushing {} buffered bytes to pane %{}",
                    data.len(),
                    tmux_pane_id
                );

                // Find the native pane and send the buffered data
                if let Some(native_pane_id) =
                    self.tmux_state.tmux_sync.get_native_pane(tmux_pane_id)
                {
                    // Find the pane across all tabs
                    for tab in self.tab_manager.tabs_mut() {
                        if let Some(pane_manager) = tab.pane_manager_mut()
                            && let Some(pane) = pane_manager.get_pane_mut(native_pane_id)
                        {
                            // try_lock: intentional â€” flushing buffered output in the sync
                            // event loop. On miss: this buffered chunk is lost. Low risk:
                            // the tmux %continue state means output has resumed and fresh
                            // data will arrive shortly to fill in any gap.
                            if let Ok(term) = pane.terminal.try_lock() {
                                term.process_data(&data);
                            }
                            break;
                        }
                    }
                }
            }
        }

        // Show toast notification to user
        self.show_toast("tmux: Output resumed");
    }

    /// Process sync actions generated by TmuxSync.
    ///
    /// TODO(issue): Wire this dispatcher up when `TmuxSync` is fully integrated into the
    /// notification poll loop. Currently `TmuxSync` generates `SyncAction` values but
    /// this method is never called. The integration requires:
    ///   1. Calling `self.tmux_state.tmux_sync.tick()` (or equivalent) each frame.
    ///   2. Collecting the returned `Vec<SyncAction>`.
    ///   3. Passing them to `self.process_sync_actions()`.
    ///
    /// Tracked in AUDIT.md as ARC-011 / QA-003. Create a GitHub issue to assign a
    /// milestone before implementing.
    // TODO(dead_code): Wire up or remove process_sync_actions by v0.26 (see TmuxSync integration)
    #[allow(dead_code)] // Planned for TmuxSync integration
    fn process_sync_actions(&mut self, actions: Vec<SyncAction>) {
        for action in actions {
            match action {
                SyncAction::CreateTab { window_id } => {
                    crate::debug_info!("TMUX", "Sync: Create tab for window @{}", window_id);
                }
                SyncAction::CloseTab { tab_id } => {
                    crate::debug_info!("TMUX", "Sync: Close tab {}", tab_id);
                }
                SyncAction::RenameTab { tab_id, name } => {
                    crate::debug_info!("TMUX", "Sync: Rename tab {} to '{}'", tab_id, name);
                }
                SyncAction::UpdateLayout { tab_id, layout: _ } => {
                    crate::debug_info!("TMUX", "Sync: Update layout for tab {}", tab_id);
                }
                SyncAction::PaneOutput { pane_id, data } => {
                    crate::debug_trace!(
                        "TMUX",
                        "Sync: Route {} bytes to pane {}",
                        data.len(),
                        pane_id
                    );
                }
                SyncAction::SessionEnded => {
                    crate::debug_info!("TMUX", "Sync: Session ended");
                    self.handle_tmux_session_ended();
                }
                SyncAction::Pause => {
                    crate::debug_info!("TMUX", "Sync: Pause");
                    self.handle_tmux_pause();
                }
                SyncAction::Continue => {
                    crate::debug_info!("TMUX", "Sync: Continue");
                    self.handle_tmux_continue();
                }
            }
        }
    }
}
